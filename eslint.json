[{"filePath":"X:\\Work\\softlaunch\\ar-base\\src\\components\\models\\BlindModel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'activeSpacing' is assigned a value but never used.","line":179,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":179,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useMemo } from 'react';\r\nimport { Group, Mesh, PlaneGeometry, Vector3 } from 'three';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { Text } from '@react-three/drei';\r\n\r\ntype BlindStyle = 'roller' | 'venetian' | 'vertical' | 'roman';\r\n\r\ninterface Dimensions {\r\n  width: number;\r\n  height: number;\r\n  drop: number;\r\n}\r\n\r\ninterface BlindModelProps {\r\n  style: BlindStyle;\r\n  color: string;\r\n  dimensions: Dimensions;\r\n  texture: 'smooth' | 'fabric' | 'woven';\r\n  showMeasurements: boolean;\r\n  openAmount: number; // 0 to 1 (0 is open/bunched up, 1 is closed/fully deployed)\r\n}\r\n\r\nexport default function BlindModel({ \r\n  style, \r\n  color, \r\n  dimensions, \r\n  texture,\r\n  showMeasurements,\r\n  openAmount \r\n}: BlindModelProps) {\r\n\r\n  const groupRef = useRef<Group>(null);\r\n  const slatsRef = useRef<Mesh[]>([]);\r\n\r\n  const scale = useMemo(() => {\r\n    const baseWidth = 2.4;\r\n    const baseHeight = 3;\r\n    return {\r\n      width: (dimensions.width / 150) * baseWidth,\r\n      height: (dimensions.height / 200) * baseHeight,\r\n    };\r\n  }, [dimensions]);\r\n\r\n  useFrame((state) => {\r\n    const time = state.clock.getElapsedTime();\r\n    if (style === 'venetian') {\r\n      // Simulate subtle breeze or adjustments\r\n      const angle = Math.sin(time * 0.5) * 0.05;\r\n      slatsRef.current.forEach((slat) => {\r\n        // When open (0), slats are horizontal. When closed (1), slats rotate to vertical blocking light.\r\n        if (slat) slat.rotation.x = angle + (openAmount * Math.PI * 0.45); \r\n      });\r\n    }\r\n    if (style === 'vertical') {\r\n      const angle = Math.sin(time * 0.3) * 0.05;\r\n      slatsRef.current.forEach((slat) => {\r\n        // When closed (1), slats rotate to form a flat plane.\r\n        if (slat) slat.rotation.y = angle + (1 - openAmount) * Math.PI * 0.45;\r\n      });\r\n    }\r\n  });\r\n\r\n  const venetianSlatCount = Math.floor(scale.height * 18); // Denser slats for realism\r\n  const verticalSlatCount = Math.floor(scale.width * 10);\r\n  const romanFoldCount = 6;\r\n\r\n  const romanGeometry = useMemo(() => {\r\n    if (style !== 'roman') return undefined;\r\n    const geometry = new PlaneGeometry(1, 1, 32, 16);\r\n    const pos = geometry.getAttribute('position');\r\n    const v = new Vector3();\r\n    for (let i = 0; i < pos.count; i++) {\r\n        v.fromBufferAttribute(pos, i);\r\n        const foldY = (v.y + 0.5) * romanFoldCount; \r\n        \r\n        // Deep folds when open, flattening when deployed\r\n        const foldZ = Math.sin(foldY * Math.PI) * 0.1 * (1.1 - openAmount);\r\n        pos.setZ(i, foldZ);\r\n    }\r\n    geometry.computeVertexNormals();\r\n    return geometry;\r\n  }, [style, romanFoldCount, openAmount]);\r\n\r\n  const texturedProps = {\r\n    roughness: texture === 'woven' ? 0.9 : texture === 'fabric' ? 0.7 : 0.3,\r\n    metalness: texture === 'smooth' ? 0.2 : 0,\r\n    clearcoat: texture === 'smooth' ? 0.5 : 0,\r\n    side: 2 as const,\r\n  };\r\n\r\n  return (\r\n    <group ref={groupRef} position={[0, 0, 0]}>\r\n      {/* Decorative Headrail */}\r\n      {style === 'vertical' ? (\r\n        <mesh position={[0, scale.height / 2 + 0.06, 0.05]} castShadow>\r\n          <boxGeometry args={[scale.width + 0.2, 0.08, 0.12]} />\r\n          <meshStandardMaterial color=\"#eeeeee\" metalness={0.8} roughness={0.2} />\r\n        </mesh>\r\n      ) : (\r\n        <mesh position={[0, scale.height / 2 + 0.05, 0.05]} castShadow>\r\n          <boxGeometry args={[scale.width + 0.1, 0.1, 0.12]} />\r\n          <meshStandardMaterial color=\"#f5f5f5\" metalness={0.4} roughness={0.4} />\r\n        </mesh>\r\n      )}\r\n\r\n      {/* 1. Roller Blind */}\r\n      {style === 'roller' && (\r\n        <group>\r\n          {/* Fabric dropping down */}\r\n          <mesh \r\n            position={[0, scale.height / 2 - (scale.height * openAmount) / 2, 0.06]}\r\n            scale={[scale.width - 0.02, scale.height * openAmount || 0.01, 1]}\r\n            castShadow\r\n            receiveShadow\r\n          >\r\n            <planeGeometry args={[1, 1, 1, 1]} />\r\n            <meshPhysicalMaterial color={color} {...texturedProps} transmission={0.2} thickness={0.01} transparent opacity={0.95} />\r\n          </mesh>\r\n          {/* Rolled up fabric inside headrail */}\r\n          <mesh \r\n            position={[0, scale.height / 2 + 0.05, 0.06]} \r\n            rotation={[0, 0, Math.PI / 2]}\r\n            castShadow\r\n          >\r\n            <cylinderGeometry args={[0.02 + (1-openAmount)*0.03, 0.02 + (1-openAmount)*0.03, scale.width - 0.04, 32]} />\r\n            <meshPhysicalMaterial color={color} {...texturedProps} />\r\n          </mesh>\r\n          {/* Bottom Weight Bar */}\r\n          <mesh \r\n            position={[0, scale.height / 2 - (scale.height * openAmount), 0.06]} \r\n            castShadow\r\n          >\r\n            <boxGeometry args={[scale.width, 0.03, 0.03]} />\r\n            <meshStandardMaterial color=\"#dddddd\" roughness={0.3} metalness={0.5} />\r\n          </mesh>\r\n        </group>\r\n      )}\r\n\r\n      {/* 2. Venetian Blind (Horizontal slats) */}\r\n      {style === 'venetian' && (\r\n         <group>\r\n            {Array.from({ length: venetianSlatCount }).map((_, i) => {\r\n               const spacing = scale.height / venetianSlatCount;\r\n               const currentDeploy = openAmount; \r\n               const bunchedSpacing = 0.008; \r\n               const activeSpacing = bunchedSpacing + (spacing - bunchedSpacing) * currentDeploy;\r\n               \r\n               // Start bunching from the bottom or top depending on how the system works. standard blinds bunch at bottom as they go up.\r\n               // We will drop them from top.\r\n               const deployedHeight = venetianSlatCount * activeSpacing;\r\n               const yPos = scale.height / 2 - i * activeSpacing - spacing / 2 - (scale.height - deployedHeight) * (1-currentDeploy);\r\n               \r\n               // Only show slats that are \"dropped\" down below the bunching\r\n               // When rolling up, they stack near the top. As yPos calculates from bunching at top:\r\n               const stackYPos = scale.height / 2 - i * bunchedSpacing - 0.02;\r\n\r\n               return (\r\n                 <mesh \r\n                   key={i} \r\n                   ref={(el) => { if (el) slatsRef.current[i] = el; }}\r\n                   position={[0, currentDeploy > 0.05 ? yPos : stackYPos, 0.05]}\r\n                   castShadow\r\n                 >\r\n                   {/* Curved slat for rigidity commonly found in venetian blinds */}\r\n                   <boxGeometry args={[scale.width - 0.05, 0.01, 0.08]} />\r\n                   <meshPhysicalMaterial color={color} {...texturedProps} />\r\n                 </mesh>\r\n               );\r\n            })}\r\n         </group>\r\n      )}\r\n\r\n      {/* 3. Vertical Blind (Hanging rotating panels) */}\r\n      {style === 'vertical' && (\r\n         <group>\r\n            {Array.from({ length: verticalSlatCount }).map((_, i) => {\r\n               const spacing = scale.width / verticalSlatCount;\r\n               const bunchedSpacing = 0.02;\r\n               const activeSpacing = bunchedSpacing + (spacing - bunchedSpacing) * openAmount;\r\n               \r\n               // Pull from left to right when opening\r\n               const startX = -scale.width / 2;\r\n               \r\n               // When fully bunched (openAmount=0), they all stack closely on the left\r\n               // When fully deployed (openAmount=1), they spread across the width\r\n               const stackX = startX + i * bunchedSpacing;\r\n               const deployX = startX + i * spacing + spacing / 2;\r\n\r\n               const xPos = stackX * (1 - openAmount) + deployX * openAmount;\r\n               \r\n               return (\r\n                 <group key={i} position={[xPos, 0, 0.05]}>\r\n                   {/* Track hanger */}\r\n                   <mesh position={[0, scale.height / 2 + 0.03, 0]}>\r\n                     <boxGeometry args={[0.01, 0.04, 0.02]} />\r\n                     <meshStandardMaterial color=\"#999999\" metalness={0.8} />\r\n                   </mesh>\r\n                   {/* Slat */}\r\n                   <mesh \r\n                     ref={(el) => { if (el) slatsRef.current[i] = el; }}\r\n                     position={[0, 0, 0]}\r\n                     castShadow\r\n                   >\r\n                     <boxGeometry args={[spacing * 0.95, scale.height - 0.05, 0.005]} />\r\n                     <meshPhysicalMaterial color={color} {...texturedProps} transmission={0.1} transparent opacity={0.9} />\r\n                   </mesh>\r\n                 </group>\r\n               );\r\n            })}\r\n         </group>\r\n      )}\r\n\r\n      {/* 4. Roman Blind (Folded fabric sections) */}\r\n      {style === 'roman' && (\r\n         <group>\r\n           {Array.from({ length: romanFoldCount }).map((_, i) => {\r\n             const segmentH = scale.height / romanFoldCount;\r\n             const bunchedH = 0.08;\r\n             \r\n             // When deployed, activeH is segmentH. When bunched, activeH is bunchedH.\r\n             const activeH = bunchedH + (segmentH - bunchedH) * openAmount;\r\n             \r\n             // Drop them from the top\r\n             const yPos = scale.height / 2 - i * activeH - activeH / 2;\r\n             \r\n             // Dynamic fold pushing out\r\n             const foldOut = Math.sin((1-openAmount)*Math.PI) * 0.08;\r\n\r\n             return (\r\n               <mesh \r\n                 key={i}\r\n                 position={[0, yPos, 0.05 + foldOut]}\r\n                 scale={[scale.width, activeH, 1]}\r\n                 geometry={romanGeometry}\r\n                 castShadow\r\n                 receiveShadow\r\n               >\r\n                 <meshPhysicalMaterial color={color} {...texturedProps} transmission={0.2} transparent opacity={0.98} />\r\n               </mesh>\r\n             )\r\n           })}\r\n         </group>\r\n      )}\r\n\r\n      {/* Frame / Window System behind the blind */}\r\n      <group position={[0, 0, -0.1]}>\r\n        <mesh position={[0, 0, 0]}>\r\n          <boxGeometry args={[scale.width + 0.15, scale.height + 0.15, 0.05]} />\r\n          <meshStandardMaterial color=\"#ffffff\" roughness={0.4} />\r\n        </mesh>\r\n        <mesh position={[0, 0, 0.03]}>\r\n          <planeGeometry args={[scale.width, scale.height]} />\r\n          <meshPhysicalMaterial color=\"#cce6ff\" transmission={0.9} transparent opacity={0.4} roughness={0.1} ior={1.5} />\r\n        </mesh>\r\n      </group>\r\n\r\n      {showMeasurements && (\r\n        <>\r\n          <Text\r\n            position={[0, scale.height / 2 + 0.3, 0]}\r\n            fontSize={0.15}\r\n            color=\"#ffffff\"\r\n            outlineWidth={0.01}\r\n            outlineColor=\"#000000\"\r\n            anchorX=\"center\"\r\n            anchorY=\"middle\"\r\n          >\r\n            {Math.round(dimensions.width)} cm\r\n          </Text>\r\n          <Text\r\n            position={[scale.width / 2 + 0.3, 0, 0]}\r\n            fontSize={0.15}\r\n            color=\"#ffffff\"\r\n            outlineWidth={0.01}\r\n            outlineColor=\"#000000\"\r\n            anchorX=\"center\"\r\n            anchorY=\"middle\"\r\n            rotation={[0, 0, -Math.PI / 2]}\r\n          >\r\n            {Math.round(dimensions.height)} cm\r\n          </Text>\r\n        </>\r\n      )}\r\n    </group>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"X:\\Work\\softlaunch\\ar-base\\src\\components\\models\\CurtainModel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"X:\\Work\\softlaunch\\ar-base\\src\\components\\models\\DrapeModel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"X:\\Work\\softlaunch\\ar-base\\src\\components\\models\\ShadeModel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useFrame' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"useFrame"},"fix":{"range":[207,255],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'slatsRef' is assigned a value but never used.","line":26,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'bambooSlatCount' is assigned a value but never used.","line":65,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":65,"endColumn":24}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useMemo } from 'react';\r\nimport { Group, PlaneGeometry, Vector3, Mesh } from 'three';\r\nimport { Text } from '@react-three/drei';\r\nimport type { ShadeStyle, Dimensions } from '../../types';\r\nimport { useFrame } from '@react-three/fiber';\r\n\r\ninterface ShadeModelProps {\r\n  style: ShadeStyle;\r\n  color: string;\r\n  dimensions: Dimensions;\r\n  texture: 'smooth' | 'fabric' | 'woven';\r\n  showMeasurements: boolean;\r\n  openAmount: number; // 0 (open/raised) to 1 (closed/lowered)\r\n}\r\n\r\nexport default function ShadeModel({ \r\n  style, \r\n  color, \r\n  dimensions, \r\n  texture,\r\n  showMeasurements,\r\n  openAmount \r\n}: ShadeModelProps) {\r\n\r\n  const groupRef = useRef<Group>(null);\r\n  const slatsRef = useRef<Mesh[]>([]);\r\n\r\n  const scale = useMemo(() => {\r\n    const baseWidth = 2.4;\r\n    const baseHeight = 3;\r\n    return {\r\n      width: (dimensions.width / 150) * baseWidth,\r\n      height: (dimensions.height / 200) * baseHeight,\r\n    };\r\n  }, [dimensions]);\r\n\r\n  const dropHeight = scale.height * openAmount; // total deployed height\r\n\r\n  // Pleated/Honeycomb geometry (zig-zag pattern)\r\n  const pleatedGeometry = useMemo(() => {\r\n    const folds = 40;\r\n    const geometry = new PlaneGeometry(1, 1, 1, folds); \r\n    const pos = geometry.getAttribute('position');\r\n    const v = new Vector3();\r\n    for (let i = 0; i < pos.count; i++) {\r\n        v.fromBufferAttribute(pos, i);\r\n        const foldY = (v.y + 0.5) * folds; \r\n        const isFoldOut = Math.floor(foldY) % 2 === 0;\r\n        const zOff = isFoldOut ? 0.04 : -0.04;\r\n        \r\n        // When more open (less dropHeight), the folds get deeper out \r\n        const compression = 1.0 - openAmount * 0.5; \r\n        pos.setZ(i, zOff * compression); \r\n    }\r\n    geometry.computeVertexNormals();\r\n    return geometry;\r\n  }, [openAmount]);\r\n\r\n  const texturedProps = {\r\n    roughness: texture === 'woven' ? 0.9 : texture === 'fabric' ? 0.8 : 0.4,\r\n    metalness: texture === 'smooth' ? 0.1 : 0,\r\n    side: 2 as const,\r\n  };\r\n\r\n  const bambooSlatCount = Math.floor(scale.height * 40);\r\n\r\n  return (\r\n    <group ref={groupRef} position={[0, 0, 0]}>\r\n      {/* Headrail */}\r\n      <mesh position={[0, scale.height / 2 + 0.05, 0.05]} castShadow>\r\n        <boxGeometry args={[scale.width + 0.1, 0.1, 0.12]} />\r\n        <meshStandardMaterial color=\"#eeeeee\" roughness={0.2} />\r\n      </mesh>\r\n\r\n      {/* Styles handling */}\r\n      \r\n      {/* 1. Pleated Shade */}\r\n      {style === 'pleated' && (\r\n        <mesh \r\n          position={[0, scale.height / 2 - dropHeight / 2, 0.05]}\r\n          scale={[scale.width, dropHeight || 0.01, 1]}\r\n          geometry={pleatedGeometry}\r\n          castShadow\r\n          receiveShadow\r\n        >\r\n          <meshPhysicalMaterial \r\n            color={color} \r\n            {...texturedProps}\r\n            transmission={0.2} \r\n            thickness={0.01}\r\n            transparent\r\n            opacity={0.9}\r\n          />\r\n        </mesh>\r\n      )}\r\n\r\n      {/* 2. Honeycomb / Cellular Shade (Double layer pleated to simulate cells) */}\r\n      {style === 'honeycomb' && (\r\n        <group position={[0, scale.height / 2 - dropHeight / 2, 0.05]}>\r\n          <mesh \r\n            position={[0, 0, 0.02]}\r\n            scale={[scale.width, dropHeight || 0.01, 1]}\r\n            geometry={pleatedGeometry}\r\n            castShadow\r\n            receiveShadow\r\n          >\r\n            <meshPhysicalMaterial \r\n              color={color} \r\n              {...texturedProps}\r\n              transmission={0.4} \r\n              thickness={0.02}\r\n            />\r\n          </mesh>\r\n          <mesh \r\n            position={[0, 0, -0.02]}\r\n            scale={[scale.width, dropHeight || 0.01, -1]} // flip depth\r\n            geometry={pleatedGeometry}\r\n            castShadow\r\n            receiveShadow\r\n          >\r\n            <meshPhysicalMaterial \r\n              color={color} \r\n              {...texturedProps}\r\n              transmission={0.4} \r\n              thickness={0.02}\r\n            />\r\n          </mesh>\r\n        </group>\r\n      )}\r\n\r\n      {/* 3. Solar Shade (Flat roller) */}\r\n      {style === 'solar' && (\r\n        <group>\r\n          {/* Hanging fabric */}\r\n          <mesh \r\n            position={[0, scale.height / 2 - dropHeight / 2, 0.05]}\r\n            scale={[scale.width, dropHeight || 0.01, 1]}\r\n            castShadow\r\n            receiveShadow\r\n          >\r\n             <planeGeometry args={[1, 1, 1, 1]} />\r\n             <meshPhysicalMaterial \r\n               color={color} \r\n               {...texturedProps}\r\n               transmission={0.7} \r\n               thickness={0.01}\r\n               transparent\r\n               opacity={0.8}\r\n             />\r\n          </mesh>\r\n          {/* Rolled up part inside headrail */}\r\n          <mesh \r\n             position={[0, scale.height / 2 + 0.05, 0.05]} \r\n             rotation={[0, 0, Math.PI / 2]}\r\n          >\r\n             <cylinderGeometry args={[0.03 + (1-openAmount)*0.03, 0.03 + (1-openAmount)*0.03, scale.width - 0.02, 16]} />\r\n             <meshPhysicalMaterial color={color} {...texturedProps} />\r\n          </mesh>\r\n        </group>\r\n      )}\r\n\r\n      {/* 4. Bamboo Shade (Horizontal woven wood) */}\r\n      {style === 'bamboo' && (\r\n        <group>\r\n            {/* The flat unrolled part */}\r\n            <mesh \r\n              position={[0, scale.height / 2 - dropHeight / 2, 0.05]}\r\n              scale={[scale.width, dropHeight || 0.01, 1]}\r\n              castShadow\r\n              receiveShadow\r\n            >\r\n               <planeGeometry args={[1, 1, 1, Math.floor(dropHeight * 40)]} />\r\n               <meshPhysicalMaterial \r\n                 color={color} \r\n                 {...texturedProps}\r\n                 transmission={0.1}\r\n                 transparent\r\n                 opacity={0.95}\r\n                 map={null} // Would use a bamboo texture ideally, but using repeating geometry/striping via material roughness could work\r\n                 roughness={0.9} // bamboo is matte but bumpy\r\n                 bumpScale={0.05}\r\n               />\r\n               {/* Drawing actual slits is expensive, using a plane with detailed horizontal subdivisions simulates the flexibility */}\r\n            </mesh>\r\n            {/* Rolled up bottom rail logic for bamboo shades */}\r\n            <mesh position={[0, scale.height / 2 - dropHeight, 0.06]} rotation={[0, 0, Math.PI/2]} castShadow>\r\n               <cylinderGeometry args={[0.02 + (1-openAmount)*0.04, 0.02 + (1-openAmount)*0.04, scale.width + 0.02, 16]} />\r\n               <meshStandardMaterial color={color} roughness={0.9} />\r\n            </mesh>\r\n        </group>\r\n      )}\r\n\r\n      {/* Bottom Rail for non-bamboo */}\r\n      {style !== 'bamboo' && (\r\n        <mesh position={[0, scale.height / 2 - dropHeight - 0.02, 0.05]} castShadow>\r\n          <boxGeometry args={[scale.width, 0.04, 0.08]} />\r\n          <meshStandardMaterial color={style === 'solar' ? '#cccccc' : '#dddddd'} roughness={0.3} />\r\n        </mesh>\r\n      )}\r\n\r\n      {/* Frame */}\r\n      <group position={[0, 0, -0.1]}>\r\n        <mesh position={[0, 0, 0]}>\r\n          <boxGeometry args={[scale.width + 0.15, scale.height + 0.15, 0.05]} />\r\n          <meshStandardMaterial color=\"#ffffff\" roughness={0.4} />\r\n        </mesh>\r\n        <mesh position={[0, 0, 0.03]}>\r\n          <planeGeometry args={[scale.width, scale.height]} />\r\n          <meshPhysicalMaterial color=\"#cce6ff\" transmission={0.9} transparent opacity={0.4} roughness={0.1} ior={1.5} />\r\n        </mesh>\r\n      </group>\r\n\r\n      {showMeasurements && (\r\n        <>\r\n          <Text position={[0, scale.height / 2 + 0.3, 0]} fontSize={0.15} color=\"#ffffff\" outlineWidth={0.01} outlineColor=\"#000000\" anchorX=\"center\" anchorY=\"middle\">\r\n            {Math.round(dimensions.width)} cm\r\n          </Text>\r\n          <Text position={[scale.width / 2 + 0.3, 0, 0]} fontSize={0.15} color=\"#ffffff\" outlineWidth={0.01} outlineColor=\"#000000\" anchorX=\"center\" anchorY=\"middle\" rotation={[0, 0, -Math.PI / 2]}>\r\n            {Math.round(dimensions.height)} cm\r\n          </Text>\r\n        </>\r\n      )}\r\n    </group>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]}]
